#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>     // Для fork() и execvp()
#include <sys/wait.h>   // Для wait()

int main() {
    printf("Launcher: Программа-запускатор стартовала.\n");

    // 1. Создаем дочерний процесс
    pid_t child_pid = fork();

    // Проверяем результат fork()
    if (child_pid < 0) {
        // Ошибка: не удалось создать дочерний процесс
        perror("fork failed");
        return 1;
    }

    if (child_pid == 0) {
        // --- Этот код выполняется ТОЛЬКО в ДОЧЕРНЕМ процессе ---
        
        printf("Child: Я - дочерний процесс. Сейчас я стану 'sequential_min_max'.\n");

        // Подготавливаем аргументы для sequential_min_max
        // argv[0] - имя программы
        // argv[1] - seed
        // argv[2] - array_size
        // Список аргументов ДОЛЖЕН заканчиваться NULL
        char *args[] = {"./sequential_min_max", "42", "1000", NULL};

        // 2. Заменяем текущий (дочерний) процесс на новый
        // execvp найдет программу в текущей директории или в PATH
        execvp(args[0], args);

        // ВАЖНО: Если execvp выполнился успешно, код ниже НИКОГДА не выполнится,
        // так как наш процесс уже стал другой программой.
        // Если мы попали сюда, значит, произошла ошибка.
        perror("execvp failed");
        return 1; // Завершаем дочерний процесс с ошибкой

    } else {
        // --- Этот код выполняется ТОЛЬКО в РОДИТЕЛЬСКОМ процессе ---

        printf("Parent: Я - родитель. Жду, пока дочерний процесс (PID: %d) завершится.\n", child_pid);

        // 3. Ждем завершения дочернего процесса
        wait(NULL);

        printf("Parent: Дочерний процесс завершился. Программа-запускатор заканчивает работу.\n");
    }

    return 0;
}